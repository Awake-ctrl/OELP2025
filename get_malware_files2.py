import pyzipper
import requests
import os
import time

MALWARE_FOLDER = "./dataset/malware3"
ZIP_FOLDER = "zips"
PASSWORD = b"infected"
TARGET_FILE_COUNT = 1000
TAGS = ["peexe", "elf", "pdf", "doc"]


os.makedirs(MALWARE_FOLDER, exist_ok=True)
os.makedirs(ZIP_FOLDER, exist_ok=True)
def fetch_hashes(limit=1000):
    print("[*] Trying to fetch hashes using tags...")
    tags = ["peexe", "elf", "pdf", "doc"]
    hashes = set()

    for tag in tags:
        print(f"[*] Fetching tag: {tag}")
        response = requests.post("https://mb-api.abuse.ch/api/v1/", data={"query": "get_tag", "selector": tag})
        if response.status_code == 200 and "data" in response.json():
            for entry in response.json()["data"]:
                sha = entry["sha256_hash"]
                if sha not in hashes:
                    hashes.add(sha)
        if len(hashes) >= limit:
            break

    if hashes:
        print(f"[✓] Fetched {len(hashes)} hashes using tags.")
        return list(hashes)[:limit]

    print("[!] Tag method failed, falling back to get_recent...")

    # Fallback to get_recent (selector 1 to 10)
    for selector in range(1, 11):
        print(f"[*] Fetching recent batch: selector={selector}")
        response = requests.post("https://mb-api.abuse.ch/api/v1/", data={"query": "get_recent", "selector": str(selector)})
        if response.status_code == 200 and "data" in response.json():
            for entry in response.json()["data"]:
                ft = entry["file_type"].lower()
                if any(x in ft for x in ["exe", "elf", "pdf", "doc"]):
                    sha = entry["sha256_hash"]
                    if sha not in hashes:
                        hashes.add(sha)
        if len(hashes) >= limit:
            break

    print(f"[✓] Total unique hashes fetched: {len(hashes)}")
    return list(hashes)[:limit]

def download_zip(sha256_hash):
    data = {'query': 'get_file', 'sha256_hash': sha256_hash}
    try:
        r = requests.post("https://mb-api.abuse.ch/api/v1/", data=data)
        if r.status_code == 200 and r.content[:4] != b"<!DO":
            zip_path = os.path.join(ZIP_FOLDER, f"{sha256_hash}.zip")
            with open(zip_path, "wb") as f:
                f.write(r.content)
            print(f"[✓] Downloaded ZIP for {sha256_hash}")
            return zip_path
        else:
            print(f"[✗] No file available for {sha256_hash}")
            return None
    except Exception as e:
        print(f"[✗] Error downloading {sha256_hash}: {e}")
        return None

def extract_files(zip_path, output_folder):
    try:
        with pyzipper.AESZipFile(zip_path) as zf:
            zf.pwd = PASSWORD
            for file_name in zf.namelist():
                ext = os.path.splitext(file_name)[1].lower()
                if ext in (".exe", ".elf", ".pdf", ".doc"):
                    out_path = os.path.join(output_folder, os.path.basename(file_name))
                    with open(out_path, "wb") as out_f:
                        out_f.write(zf.read(file_name))
                    print(f"[✓] Extracted {file_name}")
                    return True
        return False
    except Exception as e:
        print(f"[✗] Error extracting {zip_path}: {e}")
        return False

def main():
    # hashes = fetch_hashes_from_tags(TAGS, limit=TARGET_FILE_COUNT)
    hashes = fetch_hashes(limit=TARGET_FILE_COUNT)

    extracted_files = 0
    failed_files = 0

    for sha256 in hashes:
        zip_file = download_zip(sha256)
        if zip_file:
            extracted = extract_files(zip_file, MALWARE_FOLDER)
            if extracted:
                extracted_files += 1
            else:
                failed_files += 1

        print(f"[*] Extracted: {extracted_files}/{TARGET_FILE_COUNT} | Failed: {failed_files}")

        if extracted_files >= TARGET_FILE_COUNT:
            print(f"[✓] Reached the target of {TARGET_FILE_COUNT} extracted files.")
            break

        time.sleep(2)  # Delay to avoid API rate limit

    print(f"[✓] Extraction completed: {extracted_files} files successfully extracted.")
    print(f"[✗] Failed extractions: {failed_files} files.")

if __name__ == "__main__":
    main()
